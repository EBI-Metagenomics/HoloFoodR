---
title: "HoloFoodR R package â€” case study"
date: "`r Sys.Date()`"
bibliography: HoloFoodR.bib
output:
   BiocStyle::html_document:
       fig_height: 7
       fig_width: 10
       toc: yes
       toc_depth: 2
       number_sections: true
vignette: >
   %\VignetteIndexEntry{mia}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
format:
    html:
        standalone: true
---

## Introduction

[HoloFood database](https://www.holofooddata.org) is a large collection of
holo-omic and multi-omic data from two animal systems, chicken and salmon. It was
created by the HoloFood consortium. One of its objectives is to study the
interactions between animal systems, their microbiomes, and feed additives
to optimize the diet strategies of these farm animals.
For make it easily accessible, the creators provide an Application Programming
Interface (API) that permits interaction with programming languages, such as R or
Python.

We improve the accessibility by creating the HoloFoodR package that simplifies
API interaction and assists translating raw database data into R/Bioconductor
data containers, connecting to a vast ecosystem of bioinformatics R packages.

We do not aim to demonstrate HoloFoodR in isolation from the rest of the ecosystem,
but to showcase the possibility of data integration from other databases,
such as MGnify, which holds metagenomic data. Furthermore, we provide a workflow
from data exploration to advanced machine learning and multi-omics,
offering a practical example for readers.

Our main study questions are:

    - Do treatment associate with salmons' gut flora?
    - Do larger salmons have different gut microbiota compared to smaller ones?
    - Do gut microbiota have association with muscle tissue fatty acids?

```{r}
#| label: start
#| include: false

library(knitr)
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    cache = TRUE
)
```

```{r}
#| label: setup

# List of packages that we need
packages <- c(
    "ComplexHeatmap", "dplyr", "ggplot2", "ggpubr", "HoloFoodR", "knitr",
    "latex2exp", "MGnifyR", "mia", "miaViz", "MOFA2", "patchwork", "reticulate",
    "scater", "shadowtext", "stringr"
    )

# Get packages that are already installed installed
packages_already_installed <- packages[ packages %in% installed.packages() ]

# Get packages that need to be installed
packages_need_to_install <- setdiff( packages, packages_already_installed )

# Loads BiocManager into the session. Install it if it not already installed.
if( !require("BiocManager") ){
    install.packages("BiocManager")
    library("BiocManager")
}

# If there are packages that need to be installed, installs them with BiocManager
# Updates old packages
if( length(packages_need_to_install) > 0 ) {
   install(packages_need_to_install, ask = FALSE)
}

# Load all packages into session. Stop if there are packages that were not
# successfully loaded
pkgs_not_loaded <- !sapply(packages, require, character.only = TRUE)
pkgs_not_loaded <- names(pkgs_not_loaded)[ pkgs_not_loaded ]
if( length(pkgs_not_loaded) > 0 ){
    stop("Error in loading the following packages into the session: '", paste0(pkgs_not_loaded, collapse = "', '"), "'")
}
```

## Import data

We start the workflow from data retrieval. We will use [salmon data](https://www.holofooddata.org/samples/?animal__system=salmon)
and its associated fatty acid and metagenomic amplicon as an example.

### Retrieve HoloFood data

First of all, we have to query the HoloFood database to retrieve the salmon accession
numbers.

```{r}
#| label: get_animals
#| eval: false

# Get salmon samples
salmons <- HoloFoodR::doQuery("animals", system = "salmon", use.cache = TRUE)

# Get only the data that has both metagenomic amplicion and fatty acid
# data
salmons <- salmons |>
  filter(fatty_acids == TRUE & metagenomic_amplicon == TRUE)

colnames(salmons)
```

Next, we can retrieve the data associated with each salmon.

```{r}
#| label: get_animal_data
#| eval: false

# Get salmon data
salmon_data <- HoloFoodR::getData(
  accession.type = "animals",
  accession = salmons[["accession"]],
  use.cache = TRUE
)

# Get salmon samples
salmon_samples <- salmon_data[["samples"]]

# Get sample IDs
salmon_sample_ids <- unique(salmon_samples[["accession"]])

head(salmon_sample_ids)
```

The data returned above is a list of all sample accession numbers that are associated with all
salmons. For example, metagenomic amplicon samples, such as [SAMEA112750580](https://www.holofooddata.org/sample/SAMEA112750580)
or genomic sample, such as [SAMEA9068691](https://www.holofooddata.org/sample/SAMEA9068691).

We can use these accession numbers to fetch the data associated with each
sample type and store them as `experiments` in a MultiAssayExperiment (MAE) object.

```{r}
#| label: get_salmon_mae
#| eval: false

# Get salmon <- experiments as MAE object
mae <- HoloFoodR::getResult(
  salmon_sample_ids,
  use.cache = TRUE
)
```

```{r}
#| label: save_salmon_mae
#| echo: false
#| eval: false

# Save salmon MAE This must be named differently
path <- system.file("extdata", "salmon_mae_without_mgnify.RDS", package = "HoloFoodR")
saveRDS(object = mae, file = path)
```

```{r}
#| label: read_salmon_mae
#| echo: false

# Read MAE to avoid retrieval
path <- system.file("extdata", "salmon_mae_without_mgnify.RDS", package = "HoloFoodR")
mae <- readRDS(file = path)
```

### Fetch metagenomic data from MGnify

HoloFood database does not include the data for metagenomic data. This data
can be retrieved from the [MGnify portal](https://www.ebi.ac.uk/metagenomics).
For this purpose, we will use MGnifyR package, which in a similar fashion to
HoloFoodR, allows simple interaction with MGnify API.

```{r}
#| label: get_metagenomic_samples
#| eval: false

# Create MGnify object
mg <- MgnifyClient(
  useCache = TRUE,
  cacheDir = ".MGnifyR_cache"
)

# Select only metagenomic_amplicon sample type
metagenomic_salmon_samples <- salmon_samples |>
  filter(sample_type = "metagenomic_amplicon")

# Search for sample IDs in MGnify database
salmon_analysis_ids <- searchAnalysis(
  mg,
  type = "samples",
  metagenomic_salmon_samples[["accession"]]
)
```

`salmon_analysis_ids` character vector holds associations of HoloFood metagenomic
amplicon accession numbers (SAMEAxxxxxx) to their counterparts in MGnify database
(MGYAxxxxxx).

```{r}
#| label: get_metagenomic
#| eval: false

# Get metagenomic taxonomic data for salmon from MGnify
tse <- MGnifyR::getResult(
  mg,
  accession = salmon_analysis_ids,
  get.func = FALSE
)
```

```{r}
#| label: save_metagenomic
#| eval: false
#| echo: false

# Save salmon metagenomic TreeSE
path <- system.file("extdata", "salmon_metagenomic_tse.RDS", package = "HoloFoodR")
saveRDS(object = mae, file = path)
```


```{r}
#| label: read_metagenomic
#| echo: false

# saveRDS(object = tse, file = "../inst/extdata/salmon_metagenomic_tse.RDS")

# Read in salmon metagenomic TreSE object
path <- system.file("extdata", "salmon_metagenomic_tse.RDS", package = "HoloFoodR")
tse <- readRDS(file = path)
```

Data fetched from MGnify has MGnify-specific identifiers. We have to first
rename samples with HoloFood specific ID and then add the data to
MultiAssayExperiment combining all the data.

```{r}
#| label: add_metagenomic_data

# Add MGnify results to HoloFood data
mae <- addMGnify(tse, mae)
```

Now we have retrieved all the data that we are interested on this workflow.

## Data preprocess

Data cleaning is one of the most time-consuming and most important steps in
data analysis. For instance, we need to handle missing data, transform data assays,
and agglomerate the data.

In the next steps, we will:

1. Remove unnecessary data
2. Convert data from string to numeric format
3. Agglomerate metagenomic data by prevalence. We will keep only the species
that are present in more that a specified percentage of samples and are only
present at certain percentage of relative abundance in each sample. This step
is important to filter out species that are present in only a small number of
species and/or at lower abundances.
4. Transform data to prepare it for statistical analysis.
In particular, we will use log10-transformation for fatty acid data and sequential
transformation from counts to relative abundance to centered log-ratio transformation
for compositional metagenomic data. Moreover, we apply Z-score to standardize
the data to zero-mean.

### Filter and wrangle the data

Below we see upset plot that summarizes the available experiments and how samples
overlap between them.

```{r}
#| label: upsetplot

upsetSamples(mae)
```

For demonstration purposes, we will focus on investigating fatty acids and
metagenomic data (`fatty_acids_mg` and `metagenomic_amplicon`) within the trial
A performed by the HoloFood consortium. This trial the health effects of fermented seaweed added
to the diet of salmons.

```{r}
#| label: preprocess1

# Harmonize experiment names
names(mae) <- names(mae) |>
  tolower() |>
  gsub(pattern = " ", replacement = "_")

# Fetch only experiments that we need
mae <- mae[, , c("fatty_acids_mg", "metagenomic")]
names(mae) <- c("fatty_acids", "metagenomic")
# Filter MAE object to include only Trial A
mae <- mae[ , colData(mae)[["Trial code"]] == "SA", ]
```

Some values of fatty acids are under detection thresholds. We assume them to be
zeroes. Moreover, some fatty acids do not have any observations so we drop them off.

```{r}
#| label: preprocess2

# From metabolomic data, remove organ-fatty acids row because it only contains a
# string value "muscle" which denotes where the sample was drawn.
tse <- mae[[1]]
tse <- tse[!(rowData(tse)[["marker.name"]] %in% c("Organ-fatty acids")), ]
mae[[1]] <- tse

# Transform matrix to numeric. Some values are "< 0.01"
# If a number is < 0.01, assume it to be 0
assay <- assay(mae[[1]], "counts")
assay[assay == "<0.01"] <- 0
assay <- apply(assay, c(1, 2), function(x) as.numeric(gsub(",", ".", x)))

# Reassign assay back to MAE
assay(mae[[1]], "counts") <- assay

# Drop fatty acids that are not observed
mae[[1]] <- mae[[1]][ rowSums(assay(mae[[1]], "counts")) != 0, ]
```

Moreover, we need to add a few columns for the subsequent data analysis steps.
We are interested in investigating potential differences between treatment
and control, and how treatment is related to mass.

```{r}
#| label: add_treatment_group

# Add treatment group
colData(mae)[["treatment_group"]] <-
  ifelse(colData(mae)[["Treatment concentration"]] == 0, "control", "treatment")

# Add salmon host mass to MAE colData
colData(mae[[2]])[["host.gutted.mass"]] <- as.numeric(colData(mae[[2]])[["host.gutted.mass"]])
merged_data <- merge(
    x = colData(mae), y = colData(mae[[2]])[, c("animal", "host.gutted.mass")],
    all.x = TRUE, by = "animal"
    )
rownames(merged_data) <- merged_data[["animal"]]
# Order and add back
colData(mae) <- merged_data[ match(colData(mae)[["animal"]], merged_data[["animal"]]), ]

# Add animal metadata to separate experiments
mae[[1]] <- getWithColData(mae, 1)
mae[[2]] <- getWithColData(mae, 2)
```

Furthermore, as we want to analyze the effect of treatment, we must analyze
salmons at day 60 because these salmons were sampled after experimental period.
In contrast, day-0 salmons that were sampled immediately in the beginning of the trial.

Then we need to filter out all samples that are not found in both experiments
since we are interested in multi-omic data analysis.

```{r}
#| label: preprocess3

# Subset by taking only samples from day 60
samples <- colnames(mae[[2]])[ mae[[2]]$trial.timepoint == 60 ]
mae_sub <- mae
mae_sub[[2]] <- mae_sub[[2]][ , samples, ]

# Take those samples that can be found from both experiments
mae <- intersectColumns(mae)
mae_sub <- intersectColumns(mae_sub)
names(mae_sub) <- paste0(names(mae_sub), "_60")

mae <- c(mae_sub, mae)
mae
```

Now we have dataset incuding the whole experiments with the day-0 samples,
along with experiments where day-0 samples were removed.

Next we scale salmons' mass relative to the dataset. In treatment analysis,
we want to compare only salmons in the end of the trial.

```{r}
#| label: scale_weight

# Scale mass
colData(mae[[1]])[["mass"]] <- scale(colData(mae[[1]])[["host.gutted.mass"]])
colData(mae[[2]])[["mass"]] <- scale(colData(mae[[2]])[["host.gutted.mass"]])
```

### Agglomeration

Next, we can agglomerate features by prevalence to reduce the number of
low-abundant species.

First, we visualize prevalence distribution with a histogram to decide the
prevalence threshold to use. We use 0.1% detection level to filter out
extremely low-abundant species present in each sample.

```{r}
#| label: prevalence_histgoram

# Add relative transforrmed data
mae[[2]] <- transformAssay(mae[[2]], method = "relabundance")
mae[[4]] <- transformAssay(mae[[4]], method = "relabundance")

prevalence <- getPrevalence(
    mae[[2]],
    rank = "Genus",
    assay.type = "relabundance",
    na.rm = TRUE,
    sort = TRUE,
    detection = 0.1/100
    )

# Exclude microbes with 0 prevalence
prevalence <- prevalence[prevalence != 0]

hist(prevalence)
```

We can also look at the raw prevalence numbers

```{r}
#| label: display_prevalence_numbers

# Sort prevalence in decreasing order
sort(prevalence, decreasing = TRUE) |> head(10)
```

_Mycoplasma_ is present in all samples, which is not surprising as this genus was
found to be one of the most common in salmon intestine (see @zarkasiPyrosequencingbasedCharacterizationGastrointestinal2014).

We use thresholds 20% and 0.1% for prevalence and detection, respectively.

```{r}
#| label: agglomerate_prevalence

# Agglomerate by prevalence by genus
altExp(mae[[2]], "prev_genus") <- agglomerateByPrevalence(
    mae[[2]],
    assay.type = "relabundance",
    rank = "Genus",
    prevalence = 20 / 100,
    detection = 0.1 / 100
  )

# Agglomerate by prevalence by genus
altExp(mae[[4]], "prev_genus") <- agglomerateByPrevalence(
    mae[[4]],
    assay.type = "relabundance",
    rank = "Genus",
    prevalence = 20 / 100,
    detection = 0.1 / 100
  )

altExp(mae[[2]], "prev_genus")
```

### Transformation

Next, we transform the metagenomic and metabolomic data for subsequent analysis.

We first convert the metabolomic data to relative concentrations to eliminate
sample-specific biases. Next, we apply a log10 transformation to address
skewness in the data. Finally, the data is standardized to ensure all features
are on a comparable scale.

```{r}
#| label: transformation_fatty_acids

# Transform fatty acids in mg with log10
mae[[1]] <- transformAssay(
    mae[[1]],
    assay.type = "counts",
    method = "relabundance"
)
mae[[1]] <- transformAssay(
    mae[[1]],
    assay.type = "relabundance",
    method = "log10",
    pseudocount = TRUE
)

mae[[3]] <- transformAssay(
    mae[[3]],
    assay.type = "counts",
    method = "relabundance"
)
mae[[3]] <- transformAssay(
    mae[[3]],
    assay.type = "relabundance",
    method = "log10",
    pseudocount = TRUE
)
mae[[3]] <- transformAssay(
    mae[[3]],
    assay.type = "log10",
    method = "standardize",
    MARGIN = "rows"
)

# Check if the data is normalized
hist(assay(mae[[3]], "standardize"))
```

And we transform metagenomic counts first into relative abundances,
and then use centered log-ratio method to tackle the compositional data (see
@quinnFieldGuideCompositional2019).

```{r}
#| label: transformation_metagenomics

# Transform microbiome with centered log-ratio method
mae[[2]] <- transformAssay(mae[[2]], method = "relabundance", MARGIN = "cols")
mae[[2]] <- transformAssay(
    mae[[2]],
    assay.type = "counts",
    method = "clr",
    pseudocount = TRUE,
    MARGIN = "cols"
  )

# Wait until batch transformation PR is ready in mia
altExp(mae[[2]], "prev_genus") <- transformAssay(
    altExp(mae[[2]], "prev_genus"), method = "relabundance")
altExp(mae[[2]], "prev_genus") <- transformAssay(
    altExp(mae[[2]], "prev_genus"),
    assay.type = "relabundance",
    method = "clr",
    pseudocount = TRUE,
    MARGIN = "cols"
  )

# Transform microbiome with centered log-ratio method
mae[[4]] <- transformAssay(mae[[4]], method = "relabundance", MARGIN = "cols")
mae[[4]] <- transformAssay(
    mae[[4]],
    assay.type = "counts",
    method = "clr",
    pseudocount = TRUE,
    MARGIN = "cols"
  )

# Wait until batch transformation PR is ready in mia
altExp(mae[[4]], "prev_genus") <- transformAssay(
    altExp(mae[[4]], "prev_genus"), method = "relabundance")
altExp(mae[[4]], "prev_genus") <- transformAssay(
    altExp(mae[[4]], "prev_genus"),
    assay.type = "relabundance",
    method = "clr",
    pseudocount = TRUE,
    MARGIN = "cols"
  )
```

## Data analysis

### Exploration

Before proceeding to data analysis, we will visualize abundances. An abundance
plot of centered-log-ratio transformed metagenomic species
is important for general understanding of the data. Additionally,
we also indicate "control" and "treatment" groups with colors for initial
assessment of difference between the groups.

```{r}
#| label: plot_abundance

p1 <- plotAbundanceDensity(
  altExp(mae[[2]], "prev_genus"),
  assay.type = "clr",
  colour_by = "Treatment concentration"
  )

p2 <- plotAbundanceDensity(
  altExp(mae[[2]], "prev_genus"),
  assay.type = "clr",
  colour_by = "mass"
  ) + scale_fill_gradient2(
    name = "mass",
    low = "blue",
    mid = "white",
    high = "red",
    midpoint = 0
    )

p1 + p2
```

### Alpha diversity

We can measure alpha diversity of the microbiome experiment. This metric measures
diversity within a sample.

To measure the diversity of species in each sample, we will use Shannon
diversity and compare diversities in control and treatment groups.

```{r}
#| label: alpha

index <- "shannon"

# Estimate alpha diversity
mae[[2]] <- addAlpha(mae[[2]], assay.type = "counts", index = index)

# Calculate p values
pvals <- pairwise.wilcox.test(mae[[2]][[index]], mae[[2]][["treatment_group"]], p.adjust.method = "fdr")
# Put them to data.frame format
pvals <- pvals[["p.value"]] |>
    as.data.frame()
varname <- "group1"
pvals[[varname]] <- rownames(pvals)
# To long format
pvals <- reshape(
    pvals,
    direction = "long",
    varying = colnames(pvals)[ !colnames(pvals) %in% varname ],
    times = colnames(pvals)[ !colnames(pvals) %in% varname ],
    v.names = "p",
    timevar = "group2",
    idvar = "group1"
    ) |>
    na.omit()

# Round values
pvals[["p"]] <- round(pvals[["p"]], 3)
# Add y-axis position
pvals[["y.position"]] <- max(mae[[2]][[index]]) + 0.5

# Create a plot
p <- plotColData(
        mae[[2]], x = "treatment_group", y = index, colour_by = "mass",
        show_boxplot = TRUE, show_violin = FALSE) +
        theme(text = element_text(size = 10)) +
        stat_pvalue_manual(pvals)
p
```

As shown in the plot above, there are no statistically significant differences
in alpha diversity across mass categories or treatment groups (p-value >= 0.05).
However, there is some indication that treatment may be associated with an
increase in microbial community diversity.

### Beta diversity

We can use principal coordinate analysis (PCoA) based on Bray-Curtis
dissimilarity to evaluate whether this unsupervised ordination method
effectively captures the dissimilarities between samples.

```{r}
#| label: pcoa_beta_diversity

# Run PCoA
mae[[2]] <- runMDS(
    mae[[2]],
    FUN = getDissimilarity,
    method = "bray",
    assay.type = "relabundance")

# Display dissimilarity on a plot
p <- plotReducedDim(mae[[2]], "MDS", colour_by = "mass", shape_by = "treatment_group", point_size = 4)

# Calculate explained variance
e <- attr(reducedDim(mae[[2]], "MDS"), "eig")
rel_eig <- e / sum(e[e > 0])

# Add explained variance for each axis
p <- p + labs(
    x = paste("PCoA 1 (", round(100 * rel_eig[[1]], 1), "%", ")", sep = ""),
    y = paste("PCoA 2 (", round(100 * rel_eig[[2]], 1), "%", ")", sep = "")
    )

p
```

PCoA did not effectively capture the dissimilarities between treatment groups,
indicating that there are no significant patterns in microbial compositions
among the study groups.

### Cross-association analysis

We can perform cross-association analysis using Kendall method and display
significantly correlated species and fatty acids. To exclude potential false
positives from cross-association analysis, we use agglomerated and filtered data.

Since were are not anymore interested on affect of treatment, we use whole dataset.

```{r}
#| label: cross_association_analysis
#| fig-width: 15
#| fig-height: 15

# Perform cross-association analysis
res <- getCrossAssociation(
    mae,
    experiment1 = 3,
    experiment2 = 4,
    altexp2 = "prev_genus",
    method = "kendall",
    assay.type1 = "log10",
    assay.type2 = "clr",
    mode = "matrix",
    test.signif = TRUE
    )

# Create a heatmap and store it
p <- Heatmap(
    res$cor,
    # Print values to cells
    cell_fun = function(j, i, x, y, width, height, fill) {
        # If the p-value is under threshold
        if( !is.na(res$p_adj[i, j]) & res$p_adj[i, j] < 0.05 ){
            # Print "X"
          grid.shadowtext(sprintf("%s", "X"), x, y, gp = gpar(fontsize = 10, col = "white"))
        }
    },
    heatmap_legend_param = list(title = TeX("Kendall's $\\tau$"))
)
p
```

Based on the results, most of the microbes are significantly associated with
fatty acid concentrations.

### Multi-omic factor analysis

Multi-omic factor analysis (MOFA) allows us to discover latent factors that underlie
the biological differences by taking in consideration 2 or more omic assays.
To cite the original authors, "MOFA can be viewed as a statistically rigorous
generalization of (sparse) principal component analysis (PCA) to multi-omics
data".

By applying MOFA analysis, our goal is to determine whether metagenomics and
fatty acids exhibit shared variability, ultimately assessing whether the
microbial community is associated with fatty acid composition.

```{r}
#| label: fit_mofa

mae_temp <- mae[, , c(3, 4)]
mae_temp[[2]] <- altExp(mae_temp[[2]], "prev_genus")

# Extract only transformed metagenomic assays for MOFA+ analysis
assays(mae_temp[[1]]) <- assays(mae_temp[[1]])[
  names(assays(mae_temp[[1]])) %in% c("standardize")]
assays(mae_temp[[2]]) <- assays(mae_temp[[2]])[
  names(assays(mae_temp[[2]])) %in% c("counts")]

# Transform MAE object to MOFA model
model <- create_mofa_from_MultiAssayExperiment(mae_temp)

# Set model's options
model_opts <- get_default_model_options(model)
model_opts$num_factors <- 5
model_opts$likelihoods[[2]] <- "poisson"
train_opts <- get_default_training_options(model)
train_opts$maxiter <- 20000

# Change convergence mode to slightly improve accuracy
train_opts$convergence_mode <- "slow"

# Prepare MOFA model
model <- prepare_mofa(
  object = model,
  model_options = model_opts,
  training_options = train_opts
)

# Train model
model <- run_mofa(model, use_basilisk = TRUE)
```

For sanity check, we expect factors to be uncorrelated.

```{r}
#| label: check_fit

plot_factor_cor(
  model,
  method = "pearson",
  cl.ratio = 0.2,
  tl.srt = 0,
  title = "Pearson correlation between factors",
  mar=c(0, 0, 2, 0),
)
```

Overall, we do not observe highly correlated factors which is the a good sign.

Next, we will plot the variances explained by each factor.

```{r}
#| label: var_factor1
plot_variance_explained(model)
```

Factor 1 captures the majority of the variance in the metagenomics data,
although some variability remains to be captured by other factors. Factor 2
captures the shared variability between the metagenomics and fatty acid
data.

Before exploring the shared variability, we first examine which taxa's
variability is captured by Factor 1.

```{r}
#| label: plot_factor1
custom_plotter <- function(name, factor) {
    p <- plot_top_weights(
        model,
        view = name,
        factors = factor,
        nfeatures = 15
    ) +
    labs(title = paste0("Top weights of the ", name, " assay for factor ", factor))
    return(p)
}

custom_plotter("metagenomic", factor = 1)
```

From the plot above, we can see that the first factor captures mostly the
variability in mycoplasma.

```{r}
#| label: plot_factor2

p1 <- custom_plotter("metagenomic", factor = 2)
p2 <- custom_plotter("fatty_acids", factor = 2)

p1 + p2
```

From the microbes, especially Photobacterium, has a positive association with
Factor 2. Many fatty acids also show significant weights, with pentadecyclic
acid (15:0) having a positive weight and vaccenic acid (18:1n-7) having a
negative weight, among others. This indicates that as the abundance of
Photobacterium increases, there is a corresponding increase in pentadecyclic
acid and a decrease in vaccenic acid.


## Conclusions

The present case study has demonstrated how easy and fast it is to
download large dataset and transform the data into a `MultiAssayExperiment`, which
in turn gives the researchers access to an extensive plethora of downstream
tools, such `mia` and `MOFA2` that can be used to pre-process and visualize the
multi-omics data.

```{r session_info}
sessionInfo()
```
