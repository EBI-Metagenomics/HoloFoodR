---
title: "ECCB Paper HoloFood Salmon - MOFA2 Analysis"
date: "`r Sys.Date()`"
package: HoloFoodR
output:
    BiocStyle::html_document:
        fig_height: 7
        fig_width: 10
        toc: yes
        toc_depth: 2
        number_sections: true
vignette: >
    %\VignetteIndexEntry{mia}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(knitr)
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    cache = TRUE
)
```

```{r setup}
# List of packages that we need
packages <- c(
    "ggplot2", "knitr", "mia", "dplyr", "miaViz", "MOFA2",  "patchwork", "reticulate",
    "MGnifyR", "reshape2", "GGally", "IntegratedLearner", "SuperLearner",
    "bartMachine", "mcmcplots", "tidyverse", "UpSetR", "shadowtext", "ComplexHeatmap",
    "stringr", "cowplot", "caret"
    )

# Get packages that are already installed installed
packages_already_installed <- packages[ packages %in% installed.packages() ]

# Get packages that need to be installed
packages_need_to_install <- setdiff( packages, packages_already_installed )

# Loads BiocManager into the session. Install it if it not already installed.
if( !require("BiocManager") ){
    install.packages("BiocManager")
    library("BiocManager")
}

# If there are packages that need to be installed, installs them with BiocManager
# Updates old packages.
if( length(packages_need_to_install) > 0 ) {
   install(packages_need_to_install, ask = FALSE)
}

# Load all packages into session. Stop if there are packages that were not
# successfully loaded
pkgs_not_loaded <- !sapply(packages, require, character.only = TRUE)
pkgs_not_loaded <- names(pkgs_not_loaded)[ pkgs_not_loaded ]
if( length(pkgs_not_loaded) > 0 ){
    stop("Error in loading the following packages into the session: '", paste0(pkgs_not_loaded, collapse = "', '"), "'")
}
```

```{r}
# Provide Java with RAM
options(java.parameters = "-Xmx8g")
```

## Import data

### Retrieve HoloFood data

```{r get_animals, eval=FALSE}
# Get salmon samples
salmons <- HoloFoodR::doQuery("animals", system = "salmon", use.cache = TRUE)

# Get only salmon metagenomic and fatty acid data
salmons <- salmons |>
  filter(fatty_acids == TRUE & metagenomic_assembly == TRUE)
```

```{r get_animal_data, eval=FALSE}
# Get salmon data
salmon_data <- HoloFoodR::getData(
  accession.type = "animals",
  accession = salmons[["accession"]],
  use.cache = TRUE
)

# Get salmon samples
salmon_samples <- salmon_data[["samples"]]

# Get sample IDs
salmon_sample_ids <- unique(salmon_samples[["accession"]])
```

```{r get_samples, eval=FALSE}
# Get salmon MAE experiments as MAE object
mae <- HoloFoodR::getResult(
  salmon_sample_ids,
  use.cache = TRUE
)

# Save salmon MAE
saveRDS(object = salmon_mae, file = "../inst/extdata/salmon_mae_without_mgnify.RDS")

# Show available salmon experiments
experiments(mae)
```

### Fetch metagenomic data from MGnify

HoloFood database does not include the data for metagenomic assemblies which
can be retrieved from [MGnify portal](https://www.ebi.ac.uk/metagenomics).

```{r get_metagenomic_samples, eval=FALSE}
# Create MGnify object
mg <- MgnifyClient(
  useCache = TRUE,
  cacheDir = ".MGnifyR_cache"
  )

# Select only metagenomic assembly samples types
metagenomic_salmon_samples <- salmon_samples[
    salmon_samples[["sample_type"]] == "metagenomic_assembly", ]

# Search for sample IDs in MGnify database
salmon_analysis_ids <- searchAnalysis(
  mg,
  type = "samples",
  metagenomic_salmon_samples[["accession"]]
)
```

```{r get_metagenomic, eval=FALSE}
# Get metagenomic taxonomic data for salmon from MGnify
tse <- MGnifyR::getResult(
  x = mg,
  accession = salmon_analysis_ids,
  get.func = FALSE
)

# Save salmon_metagenomic_tse
saveRDS <- saveRDS(object = tse, file = "../inst/extdata/salmon_metagenomic_tse.RDS")

tse
```

Data fetched from MGnify has MGnify-specific identifiers. We have to first
rename samples with HoloFood specific ID and then add the data to
MultiAssayExperiment combining all the data.


```{r add_metagenomic_data, eval=FALSE}
.add_MGnify <- function(
        mae, tse, holofood.id = "sample_biosample",
        exp.name = "metagenomic_assembly", new.exp = "metagenomic",
        replace = TRUE){
    # Rename columns based on HoloFood ID
    colnames(tse) <- colData(tse)[[holofood.id]]

    # Merge add MGnify metagenomic data to the existing metagenomic_assembly
    # experiment. Get the experiment from HoloFood data.
    tse2 <- mae[[exp.name]]

    # Combine sample metadata
    cd1 <- as.data.frame(colData(tse))
    cd2 <- as.data.frame(colData(tse2))
    cd <- merge(
        cd1, cd2,
        by.x = holofood.id,
        by.y = "accession",
        all.x = TRUE
    )
    rownames(cd) <- cd[[holofood.id]]

    # Now order colData to ensure that order is correct
    cd <- cd[colnames(tse), ]

    # Add it to TreeSE
    colData(tse) <- DataFrame(cd, check.names = FALSE)

    # Rename to match Holofood
    colnames(tse) <- colData(tse)[[holofood.id]]

    # Now order the data based on TreeSE in MAE
    # First take those columns that can be found
    mae[[exp.name]] <- mae[[exp.name]][
        , colnames(mae[[exp.name]]) %in% colnames(tse) ]

    # Then order
    tse <- tse[, match(colnames(mae[[exp.name]]), colnames(tse))]
    # And add to MAE in place of old experiment
    if( replace ){
        mae[[exp.name]] <- tse
    } else{
        # Get sample map
        sample_map <- sampleMap(mae)
        # Get samples that are matching with those one that are being added
        add_sample_map <- sample_map[
            match(colnames(tse), sample_map[["colname"]]), ]
        # Rename the experiment
        add_sample_map[["assay"]] <- new.exp
        # Add to sample map'
        sample_map <- rbind(sample_map, add_sample_map)
        # Create MAE
        tse <- ExperimentList(temp = tse)
        names(tse) <- new.exp

        exp_list <- c(experiments(mae), tse)
        mae <- MultiAssayExperiment(
            exp_list, colData = colData(mae), sampleMap = sample_map)
    }
    return(mae)
}

mae <- .add_MGnify(mae, tse)

# Save to merged MAE object to RDS
saveRDS(object = mae, file = "../inst/extdata/salmon_mae.RDS")
```

## Data preprocess

```{r load_data}
path <- system.file("extdata", "salmon_mae.RDS", package = "HoloFoodR")
#salmon_mae <- readRDS(path)
# mae <- readRDS(path)
mae <- readRDS("../inst/extdata/salmon_mae.RDS")

# Fetch only experiments that we need
mae <- mae[, , c("FATTY ACIDS MG", "metagenomic_assembly")]
```

```{r preprocess}
# From metabolite data, remove organ-fatty acids row as it only contains a
# string value "muscle"
tse <- mae[[1]]
tse <- tse[!(rowData(tse)[["marker.name"]] %in% c("Organ-fatty acids")), ]
mae[[1]] <- tse

# Transform matrices to numeric. Some values are "< 0.01".
# If a number is < 0.01, assume it to be 0.
assay <- assay(mae[[1]], "counts")
assay[ assay == "<0.01" ] <- 0
assay <- apply(assay, c(1, 2), function(x) as.numeric(gsub(",", ".", x)))

# Reassign assay back to MAE
assay(mae[[1]], "counts") <- assay

# From metagenomics data, remove those rows that do not have taxonomy info
not_empty <- !apply(rowData(mae[[2]]), 1, function(x) all(is.na(x)))
mae[[2]] <- mae[[2]][ not_empty, ]
```

For demonstration purposes, we will focus on investigating two experiments (`FATTY ACIDS MG` and `metagenomic_assembly`) within the trial A performed by the HoloFood consortium. This trial the health effects of
fermented seaweed added to the diet of salmons

```{r preprocess2}
# Filter MAE object to include only Trial A
mae <- mae[ , colData(mae)[["Trial code"]] == "SA", ]
mae
```

```{r transformation}
# Transform fatty acids in mg with log10
mae[[1]] <- transformAssay(
    mae[[1]],
    assay.type = "counts",
    MARGIN = "samples",
    method = "log10",
    pseudocount = TRUE
)

meltAssay(mae[[2]],
          add_row_data = TRUE,
          add_col_data = TRUE,
          assay.type = "counts")

# Agglomerate metagenomics data to Genus level and add it to altExp slot
rank <- "Genus"
altExp(mae[[2]], rank) <- agglomerateByRank(mae[[2]], rank, na.rm = TRUE)

# Transform microbiome with centered log-ratio method
altExp(mae[[2]], rank) <- transformAssay(
    altExp(mae[[2]], rank), method = "relabundance")
altExp(mae[[2]], rank) <- transformAssay(
    altExp(mae[[2]], rank), assay.type = "relabundance", method = "clr", pseudocount = TRUE)
```


## Data exploration

### Data preparation

```{r}
# For cross-correlation analysis and MOFA2, replace original metagenomics data
# with agglomerated one, remove additional assays and remove additional colData.
mae_sub <- mae
mae_sub[[2]] <- altExp(mae_sub[[2]], rank)

# Filter genera by prevalence and add it to altExp slot
altExp(mae_sub[[2]], "prev_genus") <- subsetByPrevalentFeatures(mae_sub[[2]], prevalence = 0.2, detection = 0.001)

# Add Treatment concentration to alternative experiment
# Note that host.diet.treatment.concentration variable is different,
# and it is 0 for control and all other treatments except for maximum
# concentration (2, Jaguar treatment code)
mae_coldata_animal <- colData(mae)[, c("animal", "Treatment concentration")]
colData(altExp(mae_sub[[2]], "prev_genus")) <- merge(colData(altExp(mae_sub[[2]], "prev_genus")), mae_coldata_animal, by = "animal")

# Add control vs treatment groups
colData(altExp(mae_sub[[2]], "prev_genus"))["treatment_group"] <- ifelse(
  colData(altExp(mae_sub[[2]], "prev_genus") )[, "Treatment concentration"] == 0, "control", "treatment")

# Extract only transformed assays
assays(mae_sub[[1]]) <- assays(mae_sub[[1]])[ names(assays(mae_sub[[1]])) %in% c("log10") ]
# assays(mae_sub[[2]]) <- assays(mae_sub[[2]])[ names(assays(mae_sub[[2]])) %in% c("clr") ] # We might need relabundance data

# Rename column names to make them more consistent
names(colData(mae_sub)) <- tolower(gsub(" ", "_", names(colData(mae_sub))))

# Add salmon host mass to colData
merged_coldata <- merge(x = colData(mae_sub), y = colData(mae_sub[[2]])[c("animal", "host.gutted.mass")], all.x = TRUE, by = "animal")
rownames(merged_coldata) <- merged_coldata$animal
colData(mae_sub) <- merged_coldata

# Add mass categories
mass_median <- median(colData(mae_sub)[, "host.gutted.mass"])
colData(mae_sub)["mass_category"] <- ifelse(
  colData(mae_sub)[, "host.gutted.mass"] > mass_median, "heavy", "light")

# Add control vs treatment groups
colData(mae_sub)["treatment_group"] <- ifelse(
  colData(mae_sub)[, "treatment_concentration"] == 0, "control", "treatment")

# Take those samples that can be found from both experiments
mae_sub <- intersectColumns(mae_sub)
```


```{r show_metadata2}
# Display columns of MAE object to select those of interest
colData(mae) |> names()
```

### Abundance plot

```{r plot_abundance}
colData(altExp(mae[[2]]))[["host.diet.treatment"]] <- colData(altExp(mae[[2]]))[["host.diet.treatment"]] |>
  factor(levels = c(
    "Jaguar: SA 2.0% seaweed",
    "Cougar: SA 1.5% seaweed",
    "Lion: SA 1.0% seaweed",
    "Puma: SA 0.5% seaweed",
    "Tiger: SA Control"
  ))

plotAbundanceDensity(altExp(mae[[2]], rank), assay.type = "clr", colour_by = "host.diet.treatment.concentration")
```

### UpSet plot

```{r omic_intersection}
# fa_animals <- mae_sub[["FATTY ACIDS MG"]] |>
#   colData() |>
#   as.data.frame() |>
#   select(animal)
# species_animal <- mae_sub[["metagenomic_assembly"]] |>
#   colData() |>
#   as.data.frame() |>
#   select("animal")
#
# # All animals have metagenomic and metabolomic samples
# intersect(fa_animals, species_animal) |> nrow() # 179
```

```{r}
#| fig-width: 12
#| fig-height: 10
mae[[2]] |> assay()

# Show most prevalent features
head(getPrevalence(mae[[2]], rank = "Genus", detection = 1/100, sort = TRUE,
                   assay.type = "counts", as_relative = TRUE))

# Get most prevalent genera
most_prevalent_genera <- getPrevalentFeatures(altExp(mae[[2]]), detection = 0, prevalence = 50/100)

# Filter microbe tse by most prevalent genera
sub_tse <- altExp(mae[[2]])[most_prevalent_genera, ]

# Substitute values in microbe assay to prepare it for UpSet plot
# 1 means that a species is present in host
assay(sub_tse)[assay(sub_tse) >= 1] <- 1

# Prepare matrix for upset
upset_matrix <- t(assay(sub_tse))

# Delete Genus from rownames of matrix
colnames(upset_matrix) <- gsub("Genus:", "", colnames(upset_matrix))

# Change microbe matrix colnames from sample accession numbers
# to animal accession numbers
rownames(upset_matrix) <- rownames(colData(mae_sub))


m <- make_comb_mat(upset_matrix,
              top_n_sets = 5
              )

# Combination size
cs <- comb_size(m)

upset_plot <- UpSet(m,
                    top_annotation = HeatmapAnnotation(
                      "Species Intersections" = anno_barplot(cs,
                                                             ylim = c(0, max(cs) * 1.1),
                                                             border = FALSE,
                                                             gp = gpar(fill = "black"),
                                                             height = unit(4, "cm")
                    ),
        annotation_name_side = "left",
        annotation_name_rot = 90),
        column_title = "Intersections of 5 most prevalent genera"
                    )

# Prevent cut-offs
upset_plot <- draw(upset_plot, padding = unit(c(20, 20, 20, 20), "mm"))

# Column order
co = column_order(upset_plot)

# Add itnersection numbers to bar plot
decorate_annotation("Species Intersections", {
    grid.text(cs[co], x = seq_along(cs), y = unit(cs[co], "native") + unit(2, "pt"),
        default.units = "native", just = c("left", "bottom"),
        gp = gpar(fontsize = 6, col = "#404040"), rot = 0)
})
```


```{r}
# Add treatment groups to matrix
treatment_groups <- colData(mae_sub)[, "treatment_code"]
treatment_groups <- factor(treatment_groups)
# Encode
# 1: Cougar
# 2: Jaguar
# 3: Lion
# 4: Puma
# 5: Tiger # Control
numeric_treatment_groups <- as.numeric(treatment_groups)

# Encode treatment
numeric_treatment_groups[numeric_treatment_groups < 5] <- 1

# Encode control
numeric_treatment_groups[numeric_treatment_groups == 5] <- 0

upset_matrix <- cbind(upset_matrix, numeric_treatment_groups)

genera = c("Ammopiptanthus", "Medicago", "Salinimicrobium", "Photobacterium", "Mycoplasma")

# Create combination matrices for each group
m_list = tapply(seq_len(nrow(upset_matrix)), numeric_treatment_groups, function(ind) {
    m = make_comb_mat(upset_matrix[ind, genera, drop = FALSE])
    m[comb_degree(m) > 0]
})

# Normalize matrices
m_list <- normalize_comb_mat(m_list)
```


```{r}
max_set_size = max(sapply(m_list, set_size))
max_comb_size = max(sapply(m_list, comb_size))
```

```{r}
#| fig-width: 10
#| fig-height: 10
# Control vs. treatment (control: 0, treatment: 1)

# Add row labels
names(m_list) <- c("Control", "Treatment")
ht_list = NULL

for(i in seq_along(m_list)) {
    ht_list = ht_list %v%
        UpSet(m_list[[i]], row_title = paste0("", names(m_list)[i]),
            set_order = NULL, comb_order = NULL,
            top_annotation = upset_top_annotation(m_list[[i]], ylim = c(0, max_comb_size)),
            right_annotation = upset_right_annotation(m_list[[i]], ylim = c(0, max_set_size)))
}

# Draw UpSet plot
draw(ht_list,
     column_title = "UpSet plots of genera intersections by treatment group",
     padding = unit(c(2, 2, 2, 2), "cm"))
```

```{r}
#| fig-width: 10
#| fig-height: 10
# Same but with relative fractions
max_set_size = max(sapply(m_list, set_size))
rel_comb_size = sapply(m_list, function(m) {
    s = comb_size(m)
    # because the combination matrix is generated under "distinct" mode
    # the sum of `s` is the size of the full set
    s/sum(s)
})

ht_list = NULL
for(i in seq_along(m_list)) {
    ht_list = ht_list %v%
        UpSet(m_list[[i]], row_title = paste0("", names(m_list)[i]),
            set_order = NULL, comb_order = NULL,
            top_annotation = HeatmapAnnotation(
                "Relative\nfraction" = anno_barplot(
                    rel_comb_size[, i],
                    ylim = c(0, 0.5),
                    gp = gpar(fill = "black"),
                    border = FALSE,
                    height = unit(2, "cm"),
                ),
                annotation_name_side = "left",
                annotation_name_rot = 0),
            right_annotation = upset_right_annotation(m_list[[i]],
                ylim = c(0, max_set_size))
        )
}

# Draw UpSet plot
draw(ht_list, column_title = "UpSet relative fraction plots\n of genera intersections by treatment group")
```

```{r}
# Prepare metabolomic assay for UpSet plot
# metabolomic_assay <- assay(mae[[1]])
#
# # Filter all "sum" fatty acids
# to_exclude <- grep("^Sum", rownames(metabolomic_assay))
# metabolomic_assay <- metabolomic_assay[-to_exclude, ]
#
# # Order fatty acids by concentration
# max_conc_ind <- rowSums(metabolomic_assay) |> order(decreasing = TRUE)
# metabolomic_assay <- metabolomic_assay[max_conc_ind, ]
# # #
# metabolomic_assay[metabolomic_assay > 0] <- 1
# #
# upset_matrix <- t(metabolomic_assay)
#
# # Change metabolomic matrix colnames from sample accession numbers
# # to animal accession numbers
# rownames(upset_matrix) <- rownames(colData(mae_sub))
#
# # Make combination matrix
# m <- make_comb_mat(upset_matrix[, 1:31])
#
# UpSet(m)
```

## t-test by group

1. t-test on weight between 0-day salmons
2. t-test on weight between 60-day salmons

Our hypotheses are as follows:

1. $H_0$: there is no difference between salmon weights
2. $H_1$: there is a difference between salmon weights

```{r}
library(car)
# Add trial.timepoint data
mae_coldata$animal <- rownames(mae_coldata)
time_merged_coldata <- merge(x = mae_coldata, y = colData(mae_sub[[2]])[c("animal", "trial.timepoint")], all.x = TRUE, by = "animal")

# Add treatment_group to coldata
# time_merged_coldata$treatment_group <- (
#   ifelse(
#     time_merged_coldata$Treatment.concentration == 0,
#     "control",
#     "treatment")
#   )

# Set rownames
rownames(time_merged_coldata) <- time_merged_coldata$animal
#
# # Add host.gutted.mass
# time_merged_coldata <- merge(time_merged_coldata, colData(mae_sub), by = 0)

# Split dataframe into 0- and 60-day groups
day0 <- time_merged_coldata[time_merged_coldata$trial.timepoint == 0, ]
day60 <- time_merged_coldata[time_merged_coldata$trial.timepoint == 60, ]

# Levene's test for equal variances
leveneTest(host.gutted.mass ~ treatment_group, data = day0) # Equal
leveneTest(host.gutted.mass ~ treatment_group, data = day60) # Equal

# Split into two groups
day0_treatment <- day0[day0$treatment_group == "treatment", ]
day0_control <- day0[day0$treatment_group == "control", ]
day60_treatment <- day60[day60$treatment_group == "treatment", ]
day60_control <- day60[day60$treatment_group == "control", ]

# t-test
t.test(day0_treatment$host.gutted.mass, day0_control$host.gutted.mass, var.equal = TRUE) # Do not reject $H_0$
t.test(day60_treatment$host.gutted.mass, day60_control$host.gutted.mass, var.equal = TRUE) # Do not reject $H_0$
```

The addition of treatment does not change the weight of salmons.

## ALDEx2

We can perform the differential abundance analysis with ALDEx2 that uses
Dirichlet-multinomial model.

### Metagenomics

```{r aldex2_metagenomics}
library(ALDEx2)

# We are using TreeSummarizedExperiment object agglomerated by rank
# and subset with prevalence of 0.2
aldex_data <- altExp(mae_sub[[2]], "prev_genus")

# Generate Monte Carlo samples of the Dirichlet distribution
set.seed(42)
# x <- aldex.clr(assay(aldex_data), aldex_data$treatment_group) # No significantly 
# differentially abundant species (but might be interesting to look at anyway)
x <- aldex.clr(assay(aldex_data), aldex_data$host.diet.treatment.concentration)

# Compute expected values
x_tt <- aldex.ttest(x, paired.test = FALSE, verbose = FALSE)

# Compute effect size
x_effect <- aldex.effect(x, CI = TRUE, verbose = FALSE)

# Combine all outputs
aldex_out <- data.frame(x_tt, x_effect)
```

```{r aldex2_metagenomics_viz}
# ALDEx2 data visualization

# MA plot
par(mfrow = c(1, 2))

aldex.plot(aldex_out,
           type = "MA",
           test = "welch",
           main = "MA plot",
           xlab = "Log-ratio abundance",
           ylab = "Difference",
           cutoff = 0.05)

# MW plot for dispersion vs log-ratio abundance
aldex.plot(aldex_out,
           type = "MW",
           test = "welch",
           main = "Effect plot",
           xlab = "Dispersion",
           ylab = "Log-ratio abundance",
           cutoff = 0.05)

# Volcano plot
aldex.plot(aldex_out,
           type = "volcano",
           test = "welch",
           main = "Volcano plot",
           cutoff = 0.05)
```

```{r aldex2_metagenomics_summary}
aldex_out |>
  rownames_to_column(var = "Genus") |>
  filter(wi.eBH <= 0.05)  |>
  dplyr::select(Genus, we.eBH, wi.eBH, effect, overlap) |>
  knitr::kable()
```


## Cross-correlation analysis

```{r cross-correlation analysis}
#| fig-width: 15
#| fig-height: 15

# Perform cross-correlation analysis
res <- testExperimentCrossCorrelation(
    mae_sub, experiment1 = 1, experiment2 = 2,
    altexp2 = "prev_genus",
    method = "kendall",
    assay.type1 = "log10", assay.type2 = "clr",
    mode = "matrix"
    )

# Create a heatmap and store it
plot <- Heatmap(
    res$cor,
    # Print values to cells
    cell_fun = function(j, i, x, y, width, height, fill) {
        # If the p-value is under threshold
        if( !is.na(res$p_adj[i, j]) & res$p_adj[i, j] < 0.05 ){
            # Print "X"
          grid.shadowtext(sprintf("%s", "X"), x, y, gp = gpar(fontsize = 10, col = "white"))
        }
    },
    heatmap_legend_param = list(title = "", legend_height = unit(5, "cm"))
)
plot
```

## Differential abundance analysis

Differential abundance analysis of fatty acids.

```{r wilcox_test}
# Add treatment concentration and treatment code to fatty acid view
merged_fatty_acid <- merge(x = colData(mae_sub[[1]]), y = colData(mae)[c("animal", "Treatment concentration", "Treatment code")], all.x = TRUE, by = "animal")
rownames(merged_fatty_acid) <- merged_fatty_acid$accession
colData(mae_sub[[1]]) <- merged_fatty_acid

# Add treatment group to compare differential abundance of fatty acids on
colData(mae_sub[[1]])[["treatment_group"]] <- as.factor(
  ifelse(
    colData(mae_sub[[1]])[["Treatment concentration"]] == 0,
    "control",
    "treatment")
)

# Melt the data
df <- meltAssay(mae_sub[[1]], assay.type = "log10", add_col_data = "treatment_group")

p_values <- c()
assay_name <- "log10"
treatment_group <- "treatment_group"

for (name in rownames(mae_sub[[1]])) {
  temp <- df[df$FeatureID == name, ]
  formula <- as.formula(paste0(assay_name, "~", treatment_group))
  p_values <- c(p_values, wilcox.test(formula, temp)$p.value)
}

# Adjusts p-values
p_values <- p.adjust(p_values, method = "fdr")

# Create data.frame from p-values data
p_values <- data.frame(fatty_acid = rownames(mae_sub[[1]]), p_value = p_values)

# Order data by p-value in ascending oder
p_values <- p_values[order(p_values$p_value), ]

# Create a plot, store it, and print it
plot <- ggplot(p_values, aes(x = p_value)) +
    geom_histogram(bins = 30, color="darkred", fill="lightblue") +
    labs(x = "P-value", y = paste0("Number of fatty acids")) +
    geom_vline(xintercept = 0.05, color = "red")
    # geom_text(aes(0.05, 1, label = 0.05, angle = 90))  +
    # theme(text = element_text(size = 8))
plot
```

```{r}
p_values |> kable(digits = 10)
```


## PCoA with beta-diversity

We can perform PCoA analysis based on Bray-Curtis index and visualize the
results with explained variances on axis.

```{r}
library(scater)
library(patchwork)

# Add treatment group (treatment or control) to metagenomic table
tse <- mae_sub[[2]]
colData(tse) <- merge(colData(tse), colData(mae_sub)[, c("animal", "treatment_group")], by = "animal")

tse_pcoa <- runMDS(tse,
                   FUN = vegan::vegdist,
                   methods = "bray",
                   assay.type = "relabundance",
                   name = "MDS_bray")

p <- plotReducedDim(tse_pcoa, "MDS_bray",
                    colour_by = "treatment_group")

# Calculate explained variance
e <- attr(reducedDim(tse_pcoa, "MDS_bray"), "eig")
rel_eig <- e / sum(e[e > 0])

# Add explained variance for each axis
p <- p + labs(x = paste("PCoA 1 (", round(100 * rel_eig[[1]], 1),
                        "%", ")", sep = ""),
              y = paste("PCoA 2 (", round(100 * rel_eig[[2]], 1),
                        "%", ")", sep = ""))

p
```

It seems that control and treatment groups are not dissimilar.

We can also apply different methods on the same data and visualize the
results.

```{r}
# Run NMDS on relabundance assay with Bray-Curtis distances
tse_pcoa <- runNMDS(tse_pcoa,
               FUN = vegan::vegdist,
               method = "bray",
               assay.type = "relabundance",
               name = "NMDS_bray")

# Run MDS on clr assay with Aitchison distances
tse_pcoa <- runMDS(tse_pcoa,
              FUN = vegan::vegdist,
              method = "euclidean",
              assay.type = "clr",
              name = "MDS_aitchison")

# Run NMDS on clr assay with Euclidean distances
tse_pcoa <- runNMDS(tse_pcoa,
               FUN = vegan::vegdist,
               method = "euclidean",
               assay.type = "clr",
               name = "NMDS_aitchison")



plots <- lapply(c("MDS_bray", "MDS_aitchison",
                  "NMDS_bray", "NMDS_aitchison"),
                plotReducedDim,
                object = tse_pcoa,
                colour_by = "treatment_group")

# Generate multi-panel plot
wrap_plots(plots) +
  plot_layout(guides = "collect")
```
All four methods demonstrate that features from control and treatment are
not dissimilar.

## Kruskall-Wallis test

```{r kruskall_wallis}
# Vector to hold p-values
p_values <- c()

# Rename column names to make them more consistent
names(colData(mae_sub[[1]])) <- tolower(gsub(" ", "_", names(colData(mae_sub[[1]]))))

# Melt the data
df <- meltAssay(mae_sub[[1]], assay.type = "log10", add_col_data = "treatment_code")

# Set assay and response vairable
assay_name <- "log10"
treatment_code <- "treatment_code"

# Perform Kruskall-Wallis test for each fatty acid
for (name in rownames(mae_sub[[1]])) {
  temp <- df[df$FeatureID == name, ]
  formula <- as.formula(paste0(assay_name, "~", treatment_code))
  p_values <- c(p_values, kruskal.test(formula, temp)$p.value)
}

# Adjusts p-values with false discovery rate method
p_values <- p.adjust(p_values, method = "fdr")

# Create data.frame from p-values data
p_values <- data.frame(fatty_acid = rownames(mae_sub[[1]]), p_value = p_values)

# Order data by p-value in ascending oder
p_values <- p_values[order(p_values$p_value), ]

p_values
```


```{r}
library(FSA)
# Perform dunnTest for fatty acid differential abundance by treatment_code
dunnTest(log10 ~ treatment_code, data = df)
```
Interestingly, Tiger (control) and Jaguar (highest treatment concentration)
are not differentially abundant.


## MOFA analysis

```{r mofa_fit}
# Select only the column we require
colData(mae_sub) <- colData(mae_sub)[ , c("treatment_code", treatment_group, "host.gutted.mass", "mass_category"), drop = FALSE]

model <- create_mofa_from_MultiAssayExperiment(
    mae_sub,
    extract_metadata = TRUE
)

# Set model's options
model_opts <- get_default_model_options(model)
model_opts$num_factors <- 5
train_opts <- get_default_training_options(model)

# Change convergence mode to slightly improve accuracy
train_opts$convergence_mode <- "medium"

# Prepare MOFA model
model <- prepare_mofa(
  object = model,
  model_options = model_opts,
  training_options = train_opts
)

# Train model
model <- run_mofa(model, use_basilisk = TRUE)
```

## Pearson correlation between factors

For sanity check, we expect factors to be uncorrelated.

```{r check_ft}
#| fig-width: 10
plot_factor_cor(
  model,
  method = "pearson",
  cl.ratio = 0.2,
  tl.srt = 0,
  title = "Pearson correlation between factors",
  mar=c(0, 0, 2, 0),
)
```
Overall, we do not observe highly correlated factors which is the

## Visualization

### Variance explained

```{r get_variance}
# Get variance explained
var_explained <- get_variance_explained(model)

# Get total variance explained
var_explained_total <- as.data.frame(
  var_explained$r2_total$group1
)

# Get variance by factor
var_explained_factor <- as.data.frame(var_explained$r2_per_factor$group1)

# Change column names and add view names for clarity
colnames(var_explained_total) <- "var_explained"
var_explained_total["view"] <- rownames(var_explained_total)

colnames(var_explained_factor) <- c("fatty_acids", "metagenomic_assembly")
var_explained_factor["factor"] <- rownames(var_explained_factor)

# Melt dataframe for plotting
var_explained_factor_melt <- melt(
  var_explained_factor,
  id.vars = "factor",
  measure.vars = c("fatty_acids", "metagenomic_assembly"))
```

```{r plot_var_explained_by_view}
ggplot(
  data = var_explained_total,
  aes(x = view, y = var_explained, fill = view)
) +
  geom_bar(stat = "identity") +
  labs(title = "Variance explained by profile", x = "Profile", y = "Variance explained") +
  scale_x_discrete(labels = c("Fatty acids", "Metagenomics")) + # Custom x-axis ticks
  scale_y_continuous(label = c(0, 20, 40, 60, "80%")) + # Custom y-axis ticks
  theme_minimal() +
  theme(
    plot.title.position = "plot", # Align title position with plot
    legend.position = "none"
  )
```

Most of the total variance (85%) is explained by the fatty acid view. We can have
a more granular view and look at variance explained by factor and by view.

```{r plot_variance_explained_by_factor_view}
# Plot
ggplot(
  data = var_explained_factor_melt, aes(x = factor, y = value, fill = variable)
) +
  geom_bar(position = "stack", stat = "identity") +
  labs(
    title = "Variance explained by factor by profile",
    x = "", y = "Variance explained",
    fill = "Profile",
  ) +
  scale_x_discrete(labels = c(paste("Factor", 1:5))) + # Custom x-axis ticks
  ylim(0, 65) +
  scale_fill_discrete(labels = c("Fatty acids", "Metagenomics")) +
  theme_minimal() +
  theme(
    plot.title.position = "plot" # Align title position with plot
  )
```

The first factor explains variability with fatty acid view, while the only factor that explains variability within metagenomic assembly view is factor 2. Moreover,
within factor 2 metagenomic assembly view explains slightly more variability than
fatty acids (16% and 13% respectively).

## Plot factor

We can now plot single factors. For demonstration purposes, we will focus on
the second factor and color the samples by treatment group (Control vs. Treatment).

```{r plot_factor}
plot_factor(model,
  factors = 2,
  color_by = "treatment_group",
  group_by = "treatment_group",
  add_violin = TRUE
) +
  labs(fill = "Treatment group") +
  scale_fill_hue(
    labels = c(
      "Control", "Treatment"
    )
  ) +
  labs(y = "Factor 2")
```

```{r}
plot_variance_explained(model, x = "group")
```


We can observer, the the Tiger (control), and Jaguar (2% algae concentration)
have very similar patters with factor values that are concentrated in the lower
part of the violin plots for "heavy" salmons.

## Plot weights

The next step is to have a deeper look inside the observations we found above.
We can plot factor weight that should show us what fatty acids and bacterial
genera have the highest positive or negative impact on the selected factors.

### Plot top weights

It is possible to plot top weight per each view per each factor.

```{r top_weight_visualization, fig.width=8}
custom_plotter <- function(name, factor) {
    p <- plot_top_weights(
        model,
        view = name,
        factors = factor,
        nfeatures = 10
    ) +
    labs(title = paste0("Top weights of the ", name, " assay for factor ", factor))
    return(p)
}

custom_plotter("FATTY ACIDS MG", factor = 1)
custom_plotter("FATTY ACIDS MG", factor = 2)
custom_plotter("FATTY ACIDS MG", factor = 3)
custom_plotter("metagenomic_assembly", factor = 2)
```
If you focus on the first plot, which depicts the top factor weights of the
factor 1 of the fatty acid view,  you will notice that all fatty acids have
negative weights on factor 1. By taking into consideration what we observed on
the factor plot above, we can say that all these acids have lower concentrations
in most of heavy salmons within control (Tiger) and maximum concentration
treatments (Jaguar).

A better view can be offered if we color samples by their individual masses
instead of relying on median. Almost all "heavy" salmons have low concentrations
of the acids seen above.

```{r plot_factor_by_mass}
plot_factor(model,
  factors = 1,
  color_by = "host.gutted.mass",
  group_by = "treatment_code",
)
```

An interesting example comes from an unknown fatty acid 16:4n-3, which exhibits
the diametrically opposed effects in factors 1 and 3 compared to factor 2.
Specifically, it has the largest effects in factors 2 and 3, in the former case
the effect is positive, whereas in the latter case it is negative. Conversely,
it has second most significant negative effect on factor 1.

Similarly, these plots shows us that factors 2 and 3 mostly likely describe two
different treatments, which have the opposite impacts on the concentrations
of fatty acids.

### Plot weights per factor

We can also plot top weights per view for a selection of factors to have a better
overview of the impacts of different features on factors.

```{r weight_visualization2, fig.width=15}
plot_weights(
    model,
    view = 1,
    nfeatures = 8,
    factors = 1:3,
    text_size = 4,
    ) +
    labs(title = "Top 10 weights for the first three factors in fatty acid view") +
  theme(plot.title = element_text(size = 25),
        axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15)
  )
```

These graphs provide us with more high-level overview of the impacts of
the fatty acids on the factors.

We can observe that some fatty acids, such as lignoceric acid, are strongly positively associated with factor 2. Lignoceric acid, however, is negatively associated with factor 3, suggesting  that these factors describe distinct biological processes that underlie
these two factors. Conversely, gamma-linolenic acid has the opposite effects in factor 2 and factor 3. It is negatively associated with factor 2 and positively with factor 3.

Moreover, several other fatty acids differentiate the factors 2 and 3:

1. Nervonic acid (an analog of lignoceric acid)
2. Myristoleic acid
3. Paulinic acid
4. Margaric acid
5. Unknown fatty acid 16:4-3

The factor 1 has two negatively associated fatty acids in common with factor 3:
nervonic and paulinic acids. Most likely, factors 1 and 3 describe two similar underlying processes but it remains to be clarified why only these two acids
are common between the two factors. Finally, one can pose a question of
why factor 3 contains lignoceric and its analog nervonic acids, while only the former
appears in factor 3.

## Plot Factors

### Multiple Factors

We can plot multiple latent factors on a scatter plot.

```{r factor_visualization}
plot_factors(model, factors = c(1, 2, 3), color_by = "treatment_code")
```

It can be noticed that scatter plots between factors 1 and 2, and factors 2 and 3,
display two clusters:

1. The first containing exclusively Tiger (control) and Jaguar (2.0% concentration
of algae, the highest) treatment groups
2. The second containing a mixture of all groups

These plots demonstrate that we need to investigate the first cluster further
because the control and the Jaguar treatment groups might be intuitively expected
to be in two distinct clusters that reflect their opposing treatments.

These clusters are found by a non-linear dimensional reduction technique
Uniform Manifold Approximation and Projection for Dimension Reduction.

## Plot covariation patterns

```{r, fig.width=10}
# Heatmap of relationships between factor and top features
plot_data_heatmap(
    model,
    view = 1,
    factor = 1,
    features = 20,
    cluster_rows = TRUE, cluster_cols = FALSE,
    show_rownames = TRUE, show_colnames = FALSE,
    main = "Heatmap of top 20 fatty acids weight captured by factor 1"
)
```


## Non-linear dimensionality reduction

Finally, we can use trained MOFA model to cluster the samples by using non-linear methods, such as Uniform Manifold Approximation and Projection for Dimension Reduction (UMAP).

### UMAP

```{r umap}
set.seed(142)
model <- run_umap(model)

plot_dimred(
  model,
  method = "UMAP",
  color_by = "treatment_code"
) +
  labs(title = "UMAP plot of MOFA model")
```
As noted, above we also observe the same two clusters, first seen in the
scatter plots of factors.


### MOFA2 model by group

We can also find sources of variability that drive each group and find out
which sources are shared or different between the groups.

```{r mofa_group}
# Remove near-zero-variances from metagenomic assembly assay
nzv <- nearZeroVar(t(assay(mae_sub[[2]])))
no_var <- t(assay(mae_sub[[2]])[-nzv, ])
no_var <- t(no_var)
mae_sub_no_var <- mae_sub
mae_sub_no_var <- mae_sub[rownames(no_var), ,]
mae_sub_no_var[[1]] <- mae_sub[[1]]

# Transform mass category to factor
colData(mae_sub_no_var)$mass_category <- as.factor(colData(mae_sub_no_var)$mass_category)

model <- create_mofa_from_MultiAssayExperiment(
    mae_sub_no_var,
    group = "treatment_group",
    extract_metadata = TRUE
)

# Set model's options
model_opts <- get_default_model_options(model)
model_opts$num_factors <- 5
train_opts <- get_default_training_options(model)

# Change convergence mode to slightly improve accuracy
train_opts$convergence_mode <- "medium"

# Prepare MOFA model
model <- prepare_mofa(
  object = model,
  model_options = model_opts,
  training_options = train_opts
)

# Train model
model <- run_mofa(model, use_basilisk = TRUE)
```


```{r}
#| fig-width: 10
plot_variance_explained(model, x = "group", y = "view")
```

```{r}
colors <- c(
  "heavy" = "grey70",
  "light" = "#CD3278"
)

plot_factor(model,
            factor = 1,
            color_by = "mass_category", 
            scale = TRUE, 
            add_violin = TRUE, color_violin = TRUE, 
            dodge = TRUE, dot_size = 1, legend = TRUE
) + scale_color_manual(values=colors) + scale_fill_manual(values=colors)


plot_factor(model,
  factor = 1,
  color_by = "mass_category", 
  dot_size = 1.5,
  scale = TRUE, legend = FALSE
) + scale_color_manual(values=colors) + scale_fill_manual(values=colors)
```

We can now plot weights of factor 1 to determine the most important
species that impact factor 1.

```{r}
plot_weights(model,
  view = "metagenomic_assembly",
  factor = 1,
  nfeatures = 10,
  scale = T
)
```

_Mycoplasma_ genus stands out, and it has high positive weight, which
suggests that it is an abundant species in salmons with positive Factor 1
values. Most high positive numbers are located in treatment group and are salmons
from the light mass category.


```{r}
plot_top_weights(model, 
  view = "metagenomic_assembly",
  factor = 1, 
  nfeatures = 10,
  scale = T, 
  abs = T
)
```

Strangely, family _Mycoplsmataceae_ has very low weight.

```{r}
species <- c("Genus:Mycoplasma")

for (i in species) {
  
  p <- plot_factor(model,
    factor = 1,
    dot_size = 2.5,
    color_by = i
  ) + scale_colour_gradientn(colours = terrain.colors(10)) # change color scale
  
  print(p)
  
}
```

Three samples have high abundances of _Mycoplasma_ as well as one sample in
control.

## IntegratedLearner

### Data preparation

```{r}
# Get colData
mae_coldata <- colData(mae_sub)

# Create feature dataframe for IntegratedLearner
metabolomics_df <- mae_sub[[1]] |> assay("log10") |> as.data.frame()
metagenomics_df <- mae_sub[[2]] |> assay("clr") |> as.data.frame()

# Replace "sample" names to animal accession numbers
names(metabolomics_df) <- colData(mae[[1]])[, "animal"]
names(metagenomics_df) <- colData(mae[[2]])[, "animal"]

# Join feature tables together
feature_table <- rbind(metagenomics_df, metabolomics_df)

# Sanity check: are columns from colData the same as rownames of feature table
all(colnames(metagenomics_df) == rownames(colData(mae_sub))) # TRUE
all(colnames(metabolomics_df) == rownames(colData(mae_sub))) # TRUE
```

We also need to retain only features with non-zero variance

```{r feature-table-remove-zero-variance}
# Transpose feature table for subsequent filtering
feature_table_t <- as.data.frame(t(feature_table))

# Filter out out near-zero-variance features
nzv <- nearZeroVar(feature_table_t)
features_filtered <- feature_table_t[, -nzv]
features_table <- as.data.frame(t(features_filtered))
```


```{r}
# Y column for sample_metadata
Y <- as.numeric(factor(mae_coldata$mass_category))
# Change all 1s to 0 and all 2s to 1
Y <- ifelse(Y == 1, 0, ifelse(Y == 2, 1, Y))

# Create sample_metadata dataframe for IntegratedLearner
sample_metadata <- data.frame(
  Y = Y,
  subjectID = colnames(metabolomics_df)
)
rownames(sample_metadata) <- colnames(metabolomics_df)

# Create feature metadata dataframe for metagenomics
feature_metadata_metagenomics <- data.frame(
  featureID = rownames(metagenomics_df),
  featureType = "species"
)
rownames(feature_metadata_metagenomics) <- feature_metadata_metagenomics$featureID

# Create feature metadata dataframe for metabolomics
feature_metadata_metabolomics <- data.frame(
  featureID = rownames(metabolomics_df),
  featureType = "metabolites"
)
rownames(feature_metadata_metabolomics) <- feature_metadata_metabolomics$featureID

# Create feature_metadata dataframe for IntegratedLearner
feature_metadata <- rbind(feature_metadata_metagenomics, feature_metadata_metabolomics)

# Transform featureID into factors
feature_metadata$featureID <- as.factor(feature_metadata$featureID)
```

```{r}
# Mass category distribution (1: heavy, 2: light)
table(sample_metadata$Y)
```

```{r}
# Sanity check
all(rownames(feature_table) == rownames(feature_metadata)) # TRUE
all(colnames(feature_table) == rownames(sample_metadata)) # TRUE
```

### Random forest algorithm

```{r}
set.seed(423)
# Split dataframes into train and validation dataframes
feature_table_sample <- sample(
  c(TRUE, FALSE), ncol(feature_table), replace = TRUE, prob = c(0.8, 0.2))
feature_table_train <- feature_table[, feature_table_sample]
feature_table_valid <- feature_table[, !feature_table_sample]

# feature_metadata (probably not required)
# feature_metadata_train <- data.frame(feature_metadata)
# feature_metadata_valid <- data.frame(feature_metadata)

# sample_metadata
sample_metadata_train <- sample_metadata[colnames(feature_table_train), ]
sample_metadata_valid <- sample_metadata[colnames(feature_table_valid), ]

# Sanity check
all(rownames(sample_metadata_train) == colnames(feature_table_train)) # TRUE
all(rownames(sample_metadata_valid) == colnames(feature_table_valid)) # TRUE
```

```{r}
# Random forest fit
rf_fit <- IntegratedLearner(feature_table = feature_table_train,
                               sample_metadata = sample_metadata_train,
                               feature_metadata = feature_metadata,
                               feature_table_valid = feature_table_valid,
                               sample_metadata_valid = sample_metadata_valid,
                               folds = 10,
                               base_learner = "SL.randomForest",
                               meta_learner = "SL.nnls.auc",
                               verbose = TRUE,
                               family = binomial())
```

```{r}
# Visualization of AUC curves to predict heavy vs. light mass categories
plot.obj <- IntegratedLearner:::plot.learner(rf_fit)
```

When using stacked approach or metabolites, the area-under-curve is very high: 0.98.

#### Trial time points

There are two trial time points: 0 and 60 days.

After encoding 1 is 60 days, and 0 is 0 days.

```{r}
# Y column for sample_metadata
Y <- as.numeric(factor(time_merged_coldata$trial.timepoint))
# Change all 1s to 0 and all 2s to 1
Y <- ifelse(Y == 1, 0, ifelse(Y == 2, 1, Y))

# Create sample_metadata dataframe for IntegratedLearner
sample_metadata <- data.frame(
  Y = Y,
  subjectID = colnames(metabolomics_df)
)
rownames(sample_metadata) <- colnames(metabolomics_df)

# Split sample_metadata into train and validation dataframes
# feature_table and feature_metadata remain the same
sample_metadata_train <- sample_metadata[colnames(feature_table_train), ]
sample_metadata_valid <- sample_metadata[colnames(feature_table_valid), ]

# Sanity check
all(rownames(sample_metadata_train) == colnames(feature_table_train)) # TRUE
all(rownames(sample_metadata_valid) == colnames(feature_table_valid)) # TRUE
```


```{r}
# Random forest fit
rf_fit <- IntegratedLearner:::IntegratedLearner(feature_table = feature_table_train,
                               sample_metadata = sample_metadata_train,
                               feature_metadata = feature_metadata,
                               feature_table_valid = feature_table_valid,
                               sample_metadata_valid = sample_metadata_valid,
                               folds = 10,
                               base_learner = "SL.randomForest",
                               meta_learner = "SL.nnls.auc",
                               verbose = TRUE,
                               family = binomial())
```

```{r}
# Visualization (trial time points)
plot.obj <- IntegratedLearner:::plot.learner(rf_fit)
```

Trial time points can also be predicted with high accuracy.

#### Treatment group

Finally, we can test whether predictions of treatment vs. control can be made.

After encoding, control is 0, and treatment is 1.

```{r}
# Y column for sample_metadata
Y <- as.numeric(factor(mae_coldata$treatment_group))

# Change all 1s to 0 and all 2s to 1
Y <- ifelse(Y == 1, 0, ifelse(Y == 2, 1, Y))

# Create sample_metadata dataframe for IntegratedLearner
sample_metadata <- data.frame(
  Y = Y,
  subjectID = colnames(metabolomics_df)
)
rownames(sample_metadata) <- colnames(metabolomics_df)

# Split sample_metadata into train and validation dataframes
# feature_table and feature_metadata remain the same
sample_metadata_train <- sample_metadata[colnames(feature_table_train), ]
sample_metadata_valid <- sample_metadata[colnames(feature_table_valid), ]

# Sanity check
all(rownames(sample_metadata_train) == colnames(feature_table_train)) # TRUE
all(rownames(sample_metadata_valid) == colnames(feature_table_valid)) # TRUE
```

```{r}
# Random forest fit for treatment vs. control
rf_fit <- IntegratedLearner:::IntegratedLearner(feature_table = feature_table_train,
                               sample_metadata = sample_metadata_train,
                               feature_metadata = feature_metadata,
                               feature_table_valid = feature_table_valid,
                               sample_metadata_valid = sample_metadata_valid,
                               folds = 10,
                               base_learner = "SL.randomForest",
                               meta_learner = "SL.nnls.auc",
                               verbose = TRUE,
                               family = binomial())
```

```{r}
# Visualization (treatment vs. control)
plot.obj <- IntegratedLearner:::plot.learner(rf_fit)
```

Predictions for training data of random forest algorithm.

```{r}
rf_fit$yhat.train
```


Similarly, metabolites seem to be promising in predicting treatment versus control
groups and are comparable to an algorthimg from early fusion famility with
stacked architecture (see https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8921642/).

## Intermediate fusion

We can also approach this data with an intermediate fusion algorithm. In this
section, we will:

1. Apply intermediate fusion to predict treatment versus control
2. Combine the predictions from intermediate fusion with those from intermediate fusion
early fusion with Random Forest we performed before
3. Compare the performance of the intermediate fusion approach to early fusions with an AUC plot
4. Visualize the top 20 features of the metabolomic and metagenomic layers
by using logarithmic fold change (LFC)

Clearly, the predictions of treatment or control are of no interest in this case.
However, one can be interested in which features of each layer are the most important in order to distinguish control from treatment.

Code adapted from Chapter 15 of [Orchestrating Microbiome Analysis book](https://microbiome.github.io/OMA/docs/devel/pages/IntegratedLearner.html).

```{r intermediate_fusion}
##############################
# Prepare data for multiview #
##############################

# Separate omics layers
feature_metadata$featureType <- as.factor(feature_metadata$featureType)
name_layers <- levels(feature_metadata$featureType)

# Define a list
dataList <- vector("list", length = length(name_layers))
names(dataList) <- name_layers
table(feature_metadata$featureType)

# Select metabolites and species indices
metabolites_ind <- which(feature_metadata$featureType == "metabolites")
species_ind <- which(feature_metadata$featureType == "species")

# Split metabolites and species into two separate list elements
dataList[[1]] <- t(feature_table[metabolites_ind, ])
dataList[[2]] <- t(feature_table[species_ind, ])

# Extract y and X's
dataList <- lapply(dataList, as.matrix)
dataList <- lapply(dataList, scale)

# Remove missing values in columns of metabolomic matrix
dataList$metabolites <- dataList$metabolites[, !colSums(is.na(dataList$metabolites))]

# Set response variable Y to control vs. treatment
# Control: 0
# Treatment: 1
Y <- numeric_treatment_groups

########################
# Run cross-validation #
########################

set.seed(1234)
library(multiview)
library(glmnet)

cvfit <- cv.multiview(dataList, Y, family = binomial(), alpha = 0.5)
DD <- as.data.frame(as.matrix(coef_ordered(cvfit, s="lambda.min", alpha = 0.5)))
DD$standardized_coef <- as.numeric(DD$standardized_coef)
DD$coef <- as.numeric(DD$coef)
```

### Visualization

We will now compare the prediction performance of intermediate fusion with that of
early fusion.

```{r}
intermediate_pred <- stats:::predict(cvfit, newx = dataList, s = "lambda.min", alpha = 0.5, type = "response")

# Select only salmon IDs that are present in both predictions
row_names_select <- rownames(rf_fit$X_train_layers$metabolites)
intermediate_pred <- intermediate_pred[row_names_select, , drop = FALSE]

# Combine early fusion and intermediate fusion predictions
yhat.train <- cbind(rf_fit$yhat.train, coop_pred)

# Set column name to distinguish predictions algorithms
colnames(yhat.train) <- c(colnames(rf_fit$yhat.train), "intermediate fusion")

# Fetch only rows that are present in prediction's dataframe
Y <- colData(mae_sub)[row_names_select, ]
# Encode treatment and control for predictions
Y <- Y[, "treatment_group"]
Y <- ifelse(Y == "control", 0, 1)

# Extract ROC plot data
list.ROC <- vector("list", length = ncol(yhat.train))
names(list.ROC) <- colnames(yhat.train)

library(ROCR)
for (k in 1:length(list.ROC)){
  preds <- yhat.train[ ,k]
  pred <- prediction(preds, Y)
  AUC <- round(performance(pred, "auc")@y.values[[1]], 2)
  perf <- performance(pred, "sens", "spec")
  list.ROC[[k]] <- data.frame(sensitivity = slot(perf, "y.values")[[1]],
                            specificity = 1 - slot(perf, "x.values")[[1]],
                            AUC = AUC,
                            layer = names(list.ROC)[k])
}


# Combine ROC lists into a dataframe
ROC_table <- do.call("rbind", list.ROC)
```


```{r intermediate_fusion_visualization}
# Prepare data for plotting
plot_data <- ROC_table
plot_data$displayItem <- paste(plot_data$layer, " AUC = ", plot_data$AUC, sep="")
plot_data$displayItem <- factor(plot_data$displayItem,
                                    levels = unique(plot_data$displayItem))

# ROC curves
p <- ggplot(plot_data,
            aes(x = specificity,
            y = sensitivity,
            group = displayItem)) +
  geom_line(aes(x = specificity,y = sensitivity,color = displayItem)) +
  theme(legend.position = "bottom",
        legend.background=element_blank(),
        legend.box.background=element_rect(colour = "black")) +
  theme_bw() +
  xlab("False Positive Rate") +
  ylab("True Positive Rate") +
  theme(legend.position = "right", legend.direction = "vertical") +
  labs(color = '')

# Print
print(p)
```

Intermediate fusion is as efficient as the stacked early fusion of a single
metabolomic layer in distinguishing between control and treatment. However,
now we can visualize the most important features for this differentiation.

```{r intermediate_fusion_top20_features}
#| fig-width: 8
#| fig-height: 10
# Only plot top 20 features
DD <- DD %>%
  group_by(view) %>%
  top_n(n = 20, wt = abs(standardized_coef))

# Visualization
library(forcats)

p <- DD %>%
  mutate(view_col = fct_reorder(view_col, standardized_coef)) %>%
  ggplot(aes(x = view_col, y = standardized_coef, fill = view, width = 0.75)) +
  geom_bar(stat = "identity", show.legend = FALSE, width = 1) +
  coord_flip() +
  facet_wrap(~ view, scales = 'free_y', nrow = 2) +
  ylab('Standardized LFC') +
  xlab('') +
  ggtitle('IBD-associated multi-omics features') +
  theme_bw() + theme(strip.background  = element_blank(),
                     panel.grid.major = element_line(colour = "grey80"),
                     panel.border = element_blank(),
                     axis.ticks = element_line(size = 0),
                     panel.grid.minor.y = element_blank(),
                     panel.grid.major.y = element_blank())
p
```


### Bart machine algorithm

#### host.gutted.mass

For bart machine algorithm we are using full datasets, and the response
variable is continuous: `host.gutted.mass`.


```{r}
# Y column for sample_metadata
# Create sample_metadata dataframe for IntegratedLearner
Y <- mae_coldata$host.gutted.mass

sample_metadata_gutted_weight <- data.frame(
  Y = Y,
  subjectID = colnames(metabolomics_df)
)
rownames(sample_metadata_gutted_weight) <- colnames(metabolomics_df)
```


```{r}
# predict() function is conflicting with one of bartMachine algorithms
# so we need to unload it from namespace
unloadNamespace("MOFA2")

# bartMachine algorithm to predict host.gutted.weight
bart_fit <- IntegratedLearner(feature_table = feature_table,
                              sample_metadata = sample_metadata_gutted_weight,
                              feature_metadata = feature_metadata,
                              folds = 17,
                              base_learner = "SL.BART",
                              meta_learner = "SL.nnls.auc",
                              family = gaussian())
# Visualization
plot.obj <- IntegratedLearner:::plot.learner(bart_fit)
```


```{r}
# Generate credible intervals
# Requires longitudinal data for extracting very important features
bart_weights <- bart_fit$weights

bart_dataX <- bart_fit$X_train_layers
bart_dataY <- bart_fit$Y_train

bart_post.samples <- vector("list", length(bart_weights))
names(bart_post.samples) <- names(bart_dataX)

# Is not serialized when using binomial family
for (i in seq_along(bart_post.samples)) {
  bart_post.samples[[i]] <- bart_machine_get_posterior(bart_fit$model_fits$model_layers[[i]],
                                                       bart_dataX[[i]])$y_hat_posterior_samples
}

bart_weighted.post.samples <- Reduce("+", Map("*", bart_post.samples, bart_weights))
rownames(bart_weighted.post.samples) <- rownames(bart_dataX[[1]])
```

```{r}
#| fig-width: 10
#| fig-height: 7

# Get a random samples of posterior weights
post_samples <-bart_weighted.post.samples[sample(nrow(bart_weighted.post.samples), size=50), ]

# Show credible intervals for hosted.gut.weight
temp <- caterplot(t(post_samples),
          horizontal = FALSE, add = FALSE)
points(bart_dataY[temp])
title(main ="", xlab = "Observations", ylab = "Host gutted mass (in gramms)",
       line = NA, outer = FALSE)
```

We can observe in the figure above that heavy and light salmons are clearly
separated, and credible intervals are similar to each other.

```{r}
### Find most important features ###
omicsEye_theme <- function() {
# set default text format based on categorical and length
  angle = 45
  hjust = 1
  size = 6
  return (ggplot2::theme_bw() + ggplot2::theme(
    axis.text.x = ggplot2::element_text(size = 8, vjust = 1, hjust = hjust, angle = angle),
    axis.text.y = ggplot2::element_text(size = 8, hjust = 1),
    axis.title = ggplot2::element_text(size = 10),
    plot.title = ggplot2::element_text(size = 10),
    plot.subtitle = ggplot2::element_text(size = 8),
    legend.title = ggplot2::element_text(size = 6, face = 'bold'),
    legend.text = ggplot2::element_text(size = 7),
    axis.line = ggplot2::element_line(colour = 'black', size = .25),
    ggplot2::element_line(colour = 'black', size = .25),
    axis.line.x = ggplot2::element_line(colour = 'black', size = .25),
    axis.line.y = ggplot2::element_line(colour = 'black', size = .25),
    panel.border = ggplot2::element_blank(),
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank())
  )
}

myColtmp <- c("cornflowerblue","darkcyan","orchid4",
            "brown","goldenrod4","mistyrose4","darkgreen","purple")


VIMP_stack <- cbind.data.frame(bart_fit$weights)

colnames(VIMP_stack) <- c("mean")
VIMP_stack$sd <- NA
VIMP_stack$type <- "stack"


# Microbiome
qq <- bartMachine::investigate_var_importance(bart_fit$model_fits$model_layers$species, plot = FALSE)

VIMP_microbiome <- cbind.data.frame(qq$avg_var_props, qq$sd_var_props)
colnames(VIMP_microbiome) <- c("mean", "sd")
VIMP_microbiome$type <- "species"

# Metabolomics
qq <- bartMachine::investigate_var_importance(bart_fit$model_fits$model_layers$metabolites, plot = FALSE)

VIMP_metabolites <- cbind.data.frame(qq$avg_var_props, qq$sd_var_props)
colnames(VIMP_metabolites )<- c("mean", "sd")
VIMP_metabolites$type <- "metabolites"

VIMP <- as.data.frame(rbind.data.frame(VIMP_stack,
                                     VIMP_microbiome[1:20,],
                                     VIMP_metabolites[1:20,]))


VIMP <- rownames_to_column(VIMP, "ID")


p4 <- VIMP %>%
  filter(type == "stack") %>%
  arrange(desc(mean))  %>%
  ggplot(aes(y = mean, x = reorder(ID,-mean))) +
  geom_bar(stat = "identity", fill = 'darkseagreen') +
  theme_bw() +
  #coord_flip() +
  omicsEye_theme() +
  ylab("Layer Weights") +
  xlab("")


p5 <- VIMP %>%
  filter(type %in% c('species', 'metabolites')) %>%
  arrange(mean) %>%
  mutate(ID = str_replace_all(ID, fixed("_"), " ")) %>%
  mutate(type = factor(type,
                       levels = c('species', 'metabolites'),
                       labels = c('species', 'metabolites'))) %>%
  ggplot(aes(reorder(ID, -mean), mean, fill = type)) +
  facet_wrap(.~ type, scale = 'free') +
  geom_bar(stat = "identity", fill = "lightsalmon") +
  geom_errorbar(aes(ymin=ifelse(mean-sd>0,mean-sd,0), ymax=mean+sd), width=.2, position=position_dodge(.9)) +
  theme_bw() +
  coord_flip() +
  omicsEye_theme() +
  theme (strip.background = element_blank()) +
  ylab('Inclusion proportion') +
  xlab('')


plot_grid(p4,
             ncol = 1,
             labels = c('Estimated IntegratedLearner layer weights'),
             label_size = 8, vjust = 0.1)+
  theme(plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"))
```

```{r}
plot_grid(p5,
             ncol = 1,
             labels = c("Top 20 features of microbiome and metabolites layers"),
             label_size = 8, vjust = 0.1)+
  theme(plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"))
```


## XGBoost algorithm

We can also test another algorithm, namely XGboos as an alternative to
Random Forest.

### Host gutted weight

First, we will use try to predicted host gutted weight.

```{r}
# sample_metadata
sample_metadata_gutted_weight_train <- sample_metadata_gutted_weight[colnames(feature_table_train), ]
sample_metadata_gutted_weight_valid <- sample_metadata_gutted_weight[colnames(feature_table_valid), ]

# Sanity check
all(rownames(sample_metadata_gutted_weight_train) == colnames(feature_table_train)) # TRUE
all(rownames(sample_metadata_gutted_weight_valid) == colnames(feature_table_valid)) # TRUE

# Run xgboost algorithm (with linear model meta-learner)
xgboost <- IntegratedLearner(
  feature_table = feature_table_train,
  sample_metadata = sample_metadata_gutted_weight_train,
  feature_metadata = feature_metadata,
  feature_table_valid = feature_table_valid,
  sample_metadata_valid = sample_metadata_gutted_weight_valid,
  folds = 10,
  base_learner = "SL.xgboost",
  meta_learner = "SL.lm", # Use linear model as meta-learner instead of non-negative
  # least squares
  verbose = TRUE,
  family = gaussian()
)
```
```{r}
# Visualize xgboos algorithm AUC curves
plot.obj  <- IntegratedLearner:::plot.learner(xgboost)
```


```{r}
#' Test which algorithm outputs the highest R^2 metrics for Concatenated model
#' using gutted.host.weight response variable
#' @param algorithm base_learner algorithm
# Function to test algorithms (with linear model meta-learner)
test_model <- function(algorithm) {
  model <- IntegratedLearner(
  feature_table = feature_table_train,
  sample_metadata = sample_metadata_gutted_weight_train,
  feature_metadata = feature_metadata,
  feature_table_valid = feature_table_valid,
  sample_metadata_valid = sample_metadata_gutted_weight_valid,
  folds = 10,
  base_learner = algorithm,
  meta_learner = "SL.lm", # Use linear model as meta-learner instead of non-negative
  # least squares
  verbose = TRUE,
  family = gaussian()
  )

  return (model$R2.test[["stacked"]])
}

# Results
results <- list()
algorithms <- c(
  "SL.bartMachine",
  "SL.glmnet",
  "SL.svm" # Support Vector Machines
)

for (algorithm in algorithms) {
  r_squared <- test_model(algorithm)
  results[[algorithm]] <- r_squared
}

print(results)
```

`glmnet` algorithm has the highest AUC with stacked approach.


### Other algorithms

```{r}
# Run xgboost algorithm
# (fails with errors) # see code here https://rdrr.io/cran/SuperLearner/src/R/SuperLearner.R
xgboost <- IntegratedLearner(
  feature_table = feature_table_train,
  sample_metadata = sample_metadata_gutted_weight_train,
  feature_metadata = feature_metadata,
  feature_table_valid = feature_table_valid,
  sample_metadata_valid = sample_metadata_gutted_weight_valid,
  folds = 5,
  base_learner = "SL.xgboost",
  meta_learner = "SL.nnls.auc",
  verbose = TRUE,
  family = gaussian()
)
```


## Conclusions

The present case study has demonstrated how easy and fast it is to
download large dataset and transform the data into a MultiAssayExperiment, which
in turn gives the researchers access to an extensive plethora of downstream
tools, such mia and MOFA2 that can be used to pre-process and visualize the
multi-omics data.

```{r session_info}
sessionInfo()
```

